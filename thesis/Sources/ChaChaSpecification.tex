%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ChaCha Specification}
\label{chap:chacha}

To help with understanding the plugin visualization and for the sake of completeness, I will summarize the specification of the ChaCha cipher in this chapter.

ChaCha is a 256-bit stream cipher based on Salsa20, both developed by Prof. Daniel J. Bernstein. It was designed to improve diffusion per round while maintaining or even increasing the performance compared to Salsa20. This makes it more secure than Salsa20 with the same amount of rounds. It was developed in the year 2008, 3 years after Salsa20 \cite{chachaspec}.

The specification can be broken apart into three main points: \\
The \textit{quarterround} function, the \textit{littleendian} function and the hash function which utilizes the two other mentioned functions. I will start with the quarterround function.

\section{Quarterround function}
\label{sec:chacha.qr}

The ChaCha quarterround function takes in four 32-bit unsigned integers which we will name $a$, $b$, $c$ and $d$. It also returns four 32-bit unsigned integers.\\
It modifies its input values as described in the following pseudo-code:

\begin{center}
\begin{minipage}{0.5\linewidth}
\texttt{quarterround(a,b,c,d):} \\
\hspace*{1em}\texttt{a += b; d  \^{}= a; d} \verb|<<<|\texttt{= 16;} \\
\hspace*{1em}\texttt{c += d; b \^{}= c; b} \verb|<<<|\texttt{= 12;} \\
\hspace*{1em}\texttt{a += b; d \^{}= a; d} \verb|<<<|\texttt{= 8;} \\
\hspace*{1em}\texttt{c += d; b \^{}= c; b} \verb|<<<|\texttt{= 7;} \\
\hspace*{1em}\texttt{return a, b, c, d}
\end{minipage}
\end{center}

I will call one row, consisting of one addition, one XOR and one shift operation, a \textit{quarterround step}. This naming convention will be reused in Section \ref{sec:userInterface}.

\section{Littleendian function}
\label{sec:chacha.littleendian}

The littleendian function takes in one 32-bit unsigned integer and reverses its byte order; also returning a 32-bit unsigned integer.  \\
It can be implemented as follows:

\begin{center}
\begin{minipage}{0.8\linewidth}
\texttt{littleendian(x):} \\
\hspace*{1em}\texttt{x0 = (x} \verb|>>|\texttt{ 24) \& 0xff;} \\
\hspace*{1em}\texttt{x1 = (x} \verb|>>|\texttt{ 16) \& 0xff;} \\
\hspace*{1em}\texttt{x2 = (x} \verb|>>|\texttt{ 8) \& 0xff;} \\
\hspace*{1em}\texttt{x3 = x \& 0xff;} \\
\hspace*{1em}\texttt{return (x3} \verb|<<|\texttt{ 24) | (x2 }\verb|<<|\texttt{ 16) | (x1 }\verb|<<|\texttt{ 8) | x0;}
\end{minipage}
\end{center}

\begin{remark}
Its naming has nothing to do with system endianness, but was just named like this by Prof. Bernstein for unknown reasons (most likely because reversing the byte order is what needs to be done when transmitting data between systems of different endianess).
\end{remark}
