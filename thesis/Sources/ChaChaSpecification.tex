%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ChaCha Specification}
\label{chap:chacha}

To help with understanding the plugin visualization and for the sake of completeness, I will summarize the specification of the ChaCha cipher in this chapter.

ChaCha is a 256-bit stream cipher based on Salsa20, both developed by Prof. Daniel J. Bernstein. It was designed to improve diffusion per round while maintaining or even increasing the performance compared to Salsa20. This makes it more secure than Salsa20 with the same amount of rounds. It was developed in the year 2008, 3 years after Salsa20 \cite{chachaspec}.

The specification can be broken apart into five main points: \\
The \textit{quarterround} function, the \textit{littleendian} function, a hash function which utilizes the two other mentioned functions, how the 512-bit state is setup and finally, how the en-/decryption process works as a whole, bringing all the individual pieces together. 

I will start with the quarterround function.

\section{Quarterround Function}
\label{sec:chacha.qr}

The ChaCha quarterround function takes in four 32-bit unsigned integers which we will name $a$, $b$, $c$ and $d$. It also returns four 32-bit unsigned integers.\\
It modifies its input values as described in the following pseudo-code:

\begin{center}
\begin{minipage}{0.5\linewidth}
\texttt{quarterround(a,b,c,d):} \\
\hspace*{1em}\texttt{a += b; d  \^{}= a; d} \verb|<<<|\texttt{= 16;} \\
\hspace*{1em}\texttt{c += d; b \^{}= c; b} \verb|<<<|\texttt{= 12;} \\
\hspace*{1em}\texttt{a += b; d \^{}= a; d} \verb|<<<|\texttt{= 8;} \\
\hspace*{1em}\texttt{c += d; b \^{}= c; b} \verb|<<<|\texttt{= 7;} \\
\hspace*{1em}\texttt{return a, b, c, d}
\end{minipage}
\end{center}

I will call one row, consisting of one 32-bit addition, one XOR and one shift operation, a \textit{quarterround step}. This naming convention will be reused in Section \ref{sec:userInterface}.

\section{Littleendian Function}
\label{sec:chacha.littleendian}

The littleendian function takes in one 32-bit unsigned integer and reverses its byte order; also returning a 32-bit unsigned integer.  \\
It can be implemented as follows:

\begin{center}
\begin{minipage}{0.8\linewidth}
\texttt{littleendian(x):} \\
\hspace*{1em}\texttt{x0 = (x} \verb|>>|\texttt{ 24) \& 0xff;} \\
\hspace*{1em}\texttt{x1 = (x} \verb|>>|\texttt{ 16) \& 0xff;} \\
\hspace*{1em}\texttt{x2 = (x} \verb|>>|\texttt{ 8) \& 0xff;} \\
\hspace*{1em}\texttt{x3 = x \& 0xff;} \\
\hspace*{1em}\texttt{return (x3} \verb|<<|\texttt{ 24) | (x2 }\verb|<<|\texttt{ 16) | (x1 }\verb|<<|\texttt{ 8) | x0;}
\end{minipage}
\end{center}

\begin{remark}
Its naming has nothing to do with system endianness, but was just named like this by Prof. Bernstein for unknown reasons (most likely because reversing the byte order is what needs to be done when transmitting data between systems of different endianess).
\end{remark}

\section{ChaCha Hash Function}
\label{sec:chacha.hash}

The ChaCha hash function takes in 16 32-bit unsigned integers and returns 16 32-bit unsigned integers. The input vector $(y_0, y_1, y_2, \dots, y_{15})$ can be written as a 4$\times$4 matrix:

\begin{equation*}
\begin{pmatrix}
y_0 & y_1 & y_2 & y_3 \\
y_4 & y_5 & y_6 & y_7 \\
y_8 & y_9 & y_{10} & y_{11} \\
y_{12} & y_{13} & y_{14} & y_{15}\\
\end{pmatrix}
\end{equation*}

Using this matrix representation helps with understanding why Prof. Bernstein calls some rounds \textit{column rounds} and others \textit{diagonal rounds} in his paper (one round consists of four quarterrounds): \\
The ChaCha hash function iterates first through all columns and then through all diagonals of the matrix; applying the quarterround function to the four entries of each column/diagonal. After the first four quarterrounds it therefore has changed all columns of the matrix. This is what Prof. Bernstein calls a column round in his paper. After the next four quarterrounds, it changed all diagonals of the matrix which Prof. Bernstein analogously calls a diagonal round.

To summarize, the following quarterrounds make up one column round:
\begin{center}
\begin{minipage}{0.5\linewidth}
\texttt{quarterround($y_0$, $y_4$, $y_8$, $y_{12}$)} \\
\texttt{quarterround($y_1$, $y_5$, $y_9$, $y_{13}$)} \\
\texttt{quarterround($y_2$, $y_6$, $y_{10}$, $y_{14}$)} \\
\texttt{quarterround($y_3$, $y_7$, $y_{11}$, $y_{15}$)} \\
\end{minipage}
\end{center}
\noindent whereas the following quarterrounds make up one diagonal round:
\begin{center}
\begin{minipage}{0.5\linewidth}
\texttt{quarterround($y_0$, $y_5$, $y_{10}$, $y_{15}$)} \\
\texttt{quarterround($y_1$, $y_6$, $y_{11}$, $y_{12}$)} \\
\texttt{quarterround($y_2$, $y_7$, $y_8$, $y_{13}$)} \\
\texttt{quarterround($y_3$, $y_4$, $y_9$, $y_{14}$)} \\
\end{minipage}
\end{center}

After a set amount of rounds (8, 12, or 20), the input vector is added to the vector on which the quarterround function was run. Then the byte order of each matrix entry is reversed using the littleendian function.

Having explained the basic structure of the ChaCha hash function, the following pseudo-code should complete the readers comprehension of it:

\begin{center}
\begin{minipage}{\linewidth}
\texttt{chachahash(y):} \\
\hspace*{1em}\texttt{z = copy(y);}\\
\hspace*{1em}\texttt{for(i = 0; i < ROUNDS; i += 2)}\\
\hspace*{2em}\texttt{// column round}\\
\hspace*{2em}\texttt{y[0], y[4], y[8], y[12] = quarterround(y[0], y[4], y[8], y[12]);}\\
\hspace*{2em}\texttt{y[1], y[5], y[9], y[13] = quarterround(y[1], y[5], y[9], y[13]);}\\
\hspace*{2em}\texttt{y[2], y[6], y[10], y[14] = quarterround(y[2], y[6], y[10], y[14]);}\\
\hspace*{2em}\texttt{y[3], y[7], y[11], y[15] = quarterround(y[3], y[7], y[11], y[15]);}\\
\hspace*{2em}\texttt{// diagonal round}\\
\hspace*{2em}\texttt{y[0], y[5], y[10], y[15] = quarterround(y[0], y[5], y[10], y[15]);}\\
\hspace*{2em}\texttt{y[1], y[6], y[11], y[12] = quarterround(y[0], y[5], y[10], y[15]);}\\
\hspace*{2em}\texttt{y[2], y[7], y[8], y[13] = quarterround(y[0], y[5], y[10], y[15]);}\\
\hspace*{2em}\texttt{y[3], y[4], y[9], y[14] = quarterround(y[0], y[5], y[10], y[15]);}\\
\hspace*{1em}\texttt{for(i = 0; i < 16; i += 1)}\\
\hspace*{2em}\texttt{y[i] += z[i];}\\
\hspace*{2em}\texttt{y[i] = littleendian(y[i]);}\\
\hspace*{1em}\texttt{return y;}
\end{minipage}
\end{center}

\section{ChaCha State Matrix}
\label{sec:chacha.matrix}

ChaCha internally uses a 512-bit state for keystream generation. The ChaCha hash function modifies this state to generate a keystream block. \\
In this section, I will explain how the state is setup which is then passed in 32-bit blocks to the ChaCha hash function.

The state is made up of a 128-bit constant, a 256-bit key section, a 128-bit nonce section. To demonstrate that the author had no hidden intent with picking his constants (nothing-up-my-sleeve number), he defined the constants to be ``expand 16-byte k'' for 128-bit keys and ``expand 32-byte k'' for 256-bit keys in ASCII .\\
In the 128-bit key variant, the key is concatenated with itself to create a 256-bit key. This concatenated key is then used for the state setup. If the key is already 256-bit, we do nothing and just use it as it is for the state setup.\\
The nonce section, which consists of a block counter and the initialization vector, is where the original version and the IETF version differ. I will continue with the original version and later come back to the IETF version. In the original version, a 64-bit counter and a 64-bit initialization vector is used.

All state parameters are encoded by first splitting them into 32-bit chunks whose byte order is reversed except for the counter, whose byte order is first completely reversed and afterwards split into 32-bit chunks. Their 32-bit blocks are then ordered as follows to form the 512-bit state matrix:

\begin{equation*}
\begin{pmatrix}
\texttt{constant}& \texttt{constant} & \texttt{constant} & \texttt{constant} \\
\texttt{key} & \texttt{key} & \texttt{key} & \texttt{key} \\
\texttt{key} & \texttt{key} & \texttt{key} & \texttt{key} \\
\texttt{counter} & \texttt{counter} & \texttt{IV} & \texttt{IV} \\
\end{pmatrix}
\end{equation*}

Example (all numbers are in hexadecimal with \texttt{:} as separation between bytes and already split into 32-bit chunks):\\

\begin{tabular}{ l l }
 \texttt{key (256-bit)} & \texttt{01:02:03:04 05:06:07:08 09:0a:0b:0c 0d:0e:0f:10} \\ 
 & \texttt{11:12:13:14 15:16:17:18 19:1a:1b:1c 1d:1e:1f:20}\\
 \texttt{IV} & \texttt{00:11:22:33 44:55:66:77} \\  
\texttt{Counter} & \texttt{00:00:00:00 00:00:00:01} \\
\end{tabular}
\\

\noindent Since we used a 256-bit key, we will use the ASCII constants ``expand 32-byte k''. Their byte representation is:\\

\begin{tabular}{ l l }
\texttt{Constants} & \texttt{65:78:70:61 6e:64:20:33 32:2d:62:79 74:65:20:6b} \\
\end{tabular}
\\

\noindent The resulting state matrix:

\begin{equation*}
\begin{pmatrix}
\texttt{61:70:78:65}& \texttt{33:20:64:6e} & \texttt{79:62:2d:32} & \texttt{6b:20:65:74} \\
\texttt{04:03:02:01} & \texttt{08:07:06:05} & \texttt{0c:0b:0a:09} & \texttt{10:0f:0e:0d} \\
\texttt{14:13:12:11} & \texttt{18:17:16:15} & \texttt{1c:1b:1a:19} & \texttt{20:1f:1e:1d} \\
\texttt{00:00:00:01} & \texttt{00:00:00:00} & \texttt{33:22:11:00} & \texttt{77:66:55:44} \\
\end{pmatrix}
\end{equation*}

\section{En-/Decryption}
\label{sec:chacha.encryption}

To en- or decrypt a input text, it is XOR'ed with the keystream. \\
To generate the keystream, the ChaCha hash function is continously used to create 512-bit keystream blocks until we have enough to XOR every byte of the input text. The input to the ChaCha hash function is the 512-bit initial state as explained in the previous section. After each keystream block, the counter is incremented to have a different initial state as the input each time.

Since we are operating on streams, if the input message is not a multiple of 512-bit, the bits of the last block of the input message are left-aligned and the remaining bits of the keystream are dropped. This means that the output will always be the exact same length as the input.

There is no difference between en- or decryption because XOR is the inverse to itself.
